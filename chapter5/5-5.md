# 理解 JavaScript 的变量类型

> 3个关键字定义变量：var let const
>
> 不同之处：可变性、词法环境



## vs 不可变

const 不可变，let var 可变

声明时需要初始化，一旦声明完成之后，其值不可更改。 => 指向不可更改



```javascript
const firstConst = "samurai";
firstConst = "ninja";  //报错

const secondConst = {};
secondConst.weapon = "wakizashi";  //不报错

const thirdConst = [];
thirdConst.push("Yoshi");  //不报错
```



如果 const 的值是 静态变量，则不允许重新赋值；如果 const 的值是对象或者是数组类型，则可以对其增加新元素，但是不能重写。其实不可变的是引用，而不是值。



## vs 词法环境

var 一组，let 和 const 一组



关键字 var ：变量是在距离最近的 **函数内部** 或是在 **全局词法环境** 中定义的。忽略块级作用域

var 声明的变量实际上总是在 距离最近的函数内 或 全局词法环境中 注册的,<u>不关注块级作用域</u>

let 与 const 直接在最近的词法环境中定义变量（可以是<u>块级作用域内</u>、<u>循环内</u>、<u>函数内或全局环境内</u>）。我们可以用 let 和 const 定义 块级别、函数级别、全局级别的变量。

![var三种词法环境](http://markdown.icron.cc/var%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83.png)



![let const词法环境](http://markdown.icron.cc/let%20const%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83.png)

## 词法环境注册标识符

> 词法作用域又叫静态作用域，因为js的作用域在词法解析阶段就确定了
>
> 动态作用域：区别于静态作用域，即在函数调用时才决定作用域

JavaScript 代码的执行 分两个阶段：

一旦创建了新的词法环境，就会执行第一阶段。在第一阶段，没有执行代码，而是JavaScript引擎会访问并注册在当前词法环境中所声明的变量和函数。**变量和函数声明提升**

第二阶段的执行取决于变量的类型(let var const 函数声明)以及环境类型(全局环境、函数环境或块级作用域)

1.如果是创建一个函数环境，那么创建形参及函数参数的默认值。如果是非函数环境，将跳过此步骤。 

2.如果是创建全局或函数环境，就扫描当前代码进行函数声明(不会扫描其他函数的函数体)，但是不会扫描函数表达式或箭头函数。对于所找到的函数声明，将创建函数，并绑定到当前环境与函数名相同的标识符上。若该标识符已经存在，那么该标识符的值将被重写。如果是块级作用域，将跳过此步骤。 

3.扫描当前代码进行变量声明。在函数或全局环境中，找到所有当前函数以及其他函数之外通过 var 声明的变量，并找到所有在其他函数或代码块之外通过 let 或 const 定义的变量。在块级环境中，仅查找当前块中通过 let 或 const 定义的变量。对于所查找到的变量，若该标识符不存在，进行注册并将其初始化为 undefined。若该标识符已经存在，将保留其值。 

![注册标识符的过程](http://markdown.icron.cc/%E6%B3%A8%E5%86%8C%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E8%BF%87%E7%A8%8B.png)



若函数是函数声明进行定义的，则可以在函数声明之前访问函数。

若函数是函数表达式或箭头函数进行定义的，则不会在之前访问到函数

---

变量的声明会提升至函数顶部，函数的声明会提升至全局代码顶部。

其实，变量和函数的声明并没有实际发生移动，只是在代码执行之前，先在词法环境中进行注册。



:question: 两个阶段是哪两个阶段？变量提升和函数提升谁提升的高？

















