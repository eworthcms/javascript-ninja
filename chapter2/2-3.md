# 事件处理

在页面构建阶段执行的 JavaScript 代码，除了会影响全局应用状态和修改 DOM 外，还会注册事件监听器（或处理器）。这类监听器会在事件发生时，由浏览器调用执行。



## 事件处理器概述

浏览器执行环境的核心思想：同一时刻只能执行一个代码片段，单线程执行模型。

浏览器需要一种方式来跟踪已经发生但尚未处理的事件，于是，浏览器使用了事件队列。

所有已发生的事件（无论是用户生成的，例如鼠标移动或键盘按压，还是服务器生成的，例如Ajax事件）都会放在同一个事件队列中，以它们被浏览器检测到的顺序排列。



事件处理的过程：

* 浏览器检查事件队列头
* 如果浏览器没有在队列中检测到事件，则继续检查
* 如果浏览器在队列头中检测到了事件，则取出该事件并执行相应的事件处理器（如果存在）。在这个过程中，余下的事件在事件队列中耐心等待，直到轮到它们被处理



![事件处理](http://s.i9u.cc/%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86.png)





**浏览器放置事件的队列是在页面构建阶段和事件处理阶段以外的。**这个过程对于决定事件何时发生并将其推入事件队列很重要，这个过程不会参与事件处理线程。



### 事件是异步的

事件可能会以难以预计的时间和顺序发生（强制用户以某个顺序按键或单击是非常奇怪的）。我们对事件的处理，以及处理函数的调用是异步的。以下类型的事件会在其他类型事件中发生。

* 浏览器事件，例如当页面加载完成后或无法加载时
* 网络事件，例如来自服务器的响应（Ajax事件和服务器端事件）
* 用户事件，例如鼠标单击、鼠标移动和键盘事件
* 计时器事件，当 timeout 时间到期或又触发了一次时间间隔



事件处理的概念是 Web 应用的核心：代码的提前建立是为了在之后的某个时间点执行。除了全局代码，页面中的大部分代码都将作为某个事件的结果执行。





## 注册事件处理器

事件处理器是当某个特定事件发生后我们希望执行的函数。

有两种方式注册事件：

* 把函数赋值给某个特殊属性
* 通过使用内置的 addEventListener 方法



```javascript
//将一个函数赋值给window对象上的某个特定属性 onload
window.onload = function(){};

document.body.onclick = function(){};
```

把函数赋值给特殊属性是一种简单而直接的注册事件处理器方式。但是不推荐，因为对于某个事件 **只能注册一个事件处理器**。

```javascript
//注册事件处理器 可注册多个
document.body.addEventListener('mousemove',function(){
    //...
});
document.body.addEventLinstener('click',function(){
    //...
})
```



## 处理事件

当事件发生时，浏览器调用相应的事件处理器。由于单线程执行模型，所以同一时刻只能处理一个事件。任何后面的事件都只能在当前事件处理器完全结束执行后才能被处理。



为了响应用户的动作，浏览器把鼠标移动和单击事件以它们发生的次序放入事件队列：第一个是鼠标移动事件，第二个是单击事件序号1。

在事件处理阶段中，事件循环会检查队列，其发现队列的前面有一个鼠标移动事件，然后执行了相应的事件处理器序号2。当鼠标移动事件处理完毕后，轮到了等待在队列中的单击事件。当鼠标移动事件处理器函数的最后一行代码执行完毕后，JavaScript 引擎退出事件处理函数，鼠标移动事件完整的处理了序号3，事件循环再次检查序列。

![事件处理](http://s.i9u.cc/%E4%B8%A4%E4%B8%AA%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86.png)

























































